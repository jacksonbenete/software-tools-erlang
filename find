#!/usr/bin/escript

%% this is the pascal code diagram
%% --
%% find
%%   getpat
%%     makepat
%%       getccl
%%         dodash
%%       stclose
%%   match
%%     amatch
%%       omatch
%%         locate
%%       patsize

%% find -- find patterns in text
%%
%% for each line, if a match is found, return line

%% this is a mock version, should `getlines` first
find(Input, Pattern) ->
    case match(Input, Pattern) of
        true -> Input;
        false -> []
    end.

%% match -- find match anywhere on line
%%
%% returns true for match, false for mismatch
match(Line, Pattern) ->
    case amatch(Line, Pattern) of
        [] -> false;
        _ -> true
    end.

%% amatch -- look for match of pattern at line
%%
%% returns the position of all matches as a list
amatch(Line, Pattern) ->
    amatch(Line, {Pattern, Pattern}, 1, []).

amatch([], _, _, PosList) ->
    PosList;
amatch({[], []}, {_, []}, Pos, PosList) ->
    lists:concat([PosList, [Pos]]);
amatch({[], []}, _, _, PosList) ->
    PosList;

%% sequence of literal characters
amatch({InitT, _}, {Pattern, []}, Pos, PosList) ->
    amatch(InitT, {Pattern, Pattern}, Pos+1, lists:concat([PosList, [Pos]]));
amatch({InitT, [H|T]}, {Pattern, [PH|PT]}, Pos, PosList) ->
    case H =:= PH of
        true -> amatch({InitT, T}, {Pattern, PT}, Pos, PosList);
        false -> amatch(InitT, {Pattern, Pattern}, Pos+1, PosList)
    end;

%% if a single match is found, will test a sequential match
%% a single literal is a sequence of a literal + empty list,
%% so we can reuse code from a sequence of literal characters
amatch([H|T], {Pattern, [PH|PT]}, Pos, PosList) ->
    case H =:= PH of
        true -> amatch({T, T}, {Pattern, PT}, Pos, PosList);
        false -> amatch(T, {Pattern, Pattern}, Pos+1, PosList)
    end.

main([Pattern, File|_]) ->
    {Pattern, File};
main(["-t"|_]) ->
    test().

%% test 1 -- lines are properly read and written
%% test 2 -- find single character 'x' in text
%% test 3 -- match returns true or false
test() ->
    Input1 = "This is a single input.",
    Input1 = find(Input1, "i"),
    [] = find(Input1, "z"),

    [] = amatch("this is a single input", "z"),

    [3, 6, 12] = amatch("This is a line", [$i]),
    [1,2,3,4,5,6] = amatch("aaaaaa", "a"),

    [6] = amatch("Two letters", "et"),
    [1,2,3,4,5] = amatch("aaaaaa", "aa"),

    true = match("Two letters", "et"),
    false = match("foo bar", "foobar"),

    ok.

debug(Arg) ->
    ststd:putf("~w~n", [Arg]).

%% TODO
%%
%% ? any character except newline
%% % beginning of line
%% $ end of line (null string before newline)
%% [...] character class
%% [^...] negated character class
%% * closure (zero or more occurrences of previous pattern)
%%
%% @c escaped character (@%, @[, @*, @^, @-, @@, @])
%% an escape sequence consist of @n (newline), @t (tab)
%% or @c (escaped character)
