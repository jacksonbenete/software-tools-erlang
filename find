#!/usr/bin/escript

%% this is the pascal code diagram
%% --
%% find
%%   getpat
%%     makepat
%%       getccl
%%         dodash
%%       stclose
%%   match
%%     amatch
%%       omatch
%%         locate
%%       patsize

%% find -- find patterns in text
%%
%% for each line, if a match is found, return line

%% this is a mock version, should `getlines` first
find(Pattern, Input) ->
    case match(Pattern, Input) of
        true -> Input;
        false -> []
    end.

%% match -- find match anywhere on line
%%
%% returns true for match, false for mismatch
match(Pattern, Line) ->
    case amatch(Pattern, Line) of
        [] -> false;
        _ -> true
    end.

%% amatch -- look for match of pattern at line
%%
%% returns the position of all matches as a list
%%
%% General cases should be lower in order, metacharacters and classes 
%% need to check pattern matching first.
amatch(Pattern, Line) ->
    amatch({Pattern, Pattern}, Line, 1, []).

amatch(_, [], _, PosList) ->
    PosList;
amatch({_, []}, {[], []}, Pos, PosList) ->
    lists:concat([PosList, [Pos]]);
amatch(_, {[], []}, _, PosList) ->
    PosList;

%% ? -- match any single character except newline
%% if ? = 10 = newline, will be a mismatch
amatch({Pattern, [PH|PT]}, [H|T], Pos, PosList) when PH =:= $? ->
    case H =/= 10 of
        true -> amatch({Pattern, PT}, {T, T}, Pos, PosList);
        false -> amatch({Pattern, Pattern}, T, Pos+1, PosList)
    end;
amatch({Pattern, [PH|PT]}, {InitT, [H|T]}, Pos, PosList) when PH =:= $? ->
    case H =/= 10 of
        true -> amatch({Pattern, PT}, {InitT, T}, Pos, PosList);
        false -> amatch({Pattern, Pattern}, InitT, Pos+1, PosList)
    end;

%% sequence of literal characters
amatch({Pattern, []}, {InitT, _}, Pos, PosList) ->
    amatch({Pattern, Pattern}, InitT, Pos+1, lists:concat([PosList, [Pos]]));
amatch({Pattern, [PH|PT]}, {InitT, [H|T]}, Pos, PosList) ->
    case H =:= PH of
        true -> amatch({Pattern, PT}, {InitT, T}, Pos, PosList);
        false -> amatch({Pattern, Pattern}, InitT, Pos+1, PosList)
    end;

%% if a single match is found, will test a sequential match
%% a single literal is a sequence of a literal + empty list,
%% so we can reuse code from a sequence of literal characters
amatch({Pattern, [PH|PT]}, [H|T], Pos, PosList) ->
    case H =:= PH of
        true -> amatch({Pattern, PT}, {T, T}, Pos, PosList);
        false -> amatch({Pattern, Pattern}, T, Pos+1, PosList)
    end.

main([Pattern, File|_]) ->
    {Pattern, File};
main(["-t"|_]) ->
    test().

test() ->
    %% test 1 -- lines are properly read and written
    Input1 = "This is a single input.",
    Input1 = find("i", Input1),
    [] = find("z", Input1),

    %% test 2 -- find single character 'x' in text
    %%        -- find literal sequence 'xx' in text
    [] = amatch("z", "this is a single input"),

    [3, 6, 12] = amatch([$i], "This is a line"),
    [1,2,3,4,5,6] = amatch("a", "aaaaaa"),

    [6] = amatch("et", "Two letters"),
    [1,2,3,4,5] = amatch("aa", "aaaaaa"),

    %% test 3 -- match returns true or false
    true = match("et", "Two letters"),
    false = match("foobar", "foo bar"),

    %% test 4 -- ? matches any character except newline
    true = match("?", [32]), % ASCII 32 = whitespace
    true = match("?", " "),
    false = match("?", ""),
    true = match("?", "aaa"),
    false = match("?", [$\n]),

    AnyInput = "Match everything",
    AnyRange = lists:seq(1, erlang:length(AnyInput)),

    true = match("?", AnyInput),
    false = match("?z", AnyInput),
    AnyRange = amatch("?", AnyInput),
    AnyRange = amatch("?", AnyInput++[$\n]),
    [2, 11, 18, 27] = amatch("?t", AnyInput++AnyInput),
    [2, 11, 19, 28] = amatch("?t", AnyInput++[$\n]++AnyInput),

    true = match("?t?", AnyInput),
    [2, 11] = amatch("?t?", AnyInput),

    ok.

debug(Arg) ->
    ststd:putf("~w~n", [Arg]).

%% TODO
%%
%% % beginning of line
%% $ end of line (null string before newline)
%% [...] character class
%% [^...] negated character class
%% * closure (zero or more occurrences of previous pattern)
%%
%% @c escaped character (@%, @[, @*, @^, @-, @@, @])
%% an escape sequence consist of @n (newline), @t (tab)
%% or @c (escaped character)
