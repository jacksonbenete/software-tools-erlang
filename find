#!/usr/bin/escript

%% this is the pascal code diagram
%% --
%% find
%%   getpat
%%     makepat
%%       getccl
%%         dodash
%%       stclose
%%   match
%%     amatch
%%       omatch
%%         locate
%%       patsize

%% find -- find patterns in text
%%
%% for each line, if a match is found, return line

%% this is a mock version, should `getlines` first
find(Pattern, Input) ->
    case match(Pattern, Input) of
        true -> Input;
        false -> []
    end.

%% match -- find match anywhere on line
%%
%% returns true for match, false for mismatch
match(Pattern, Line) ->
    case amatch(Pattern, Line) of
        [] -> false;
        _ -> true
    end.

%% amatch -- look for match of pattern at line
%%
%% returns the position of all matches as a list
%%
%% General cases should be lower in order, metacharacters and classes 
%% need to check pattern matching first.
amatch(Pattern, Line) ->
    amatch({Pattern, Pattern}, Line, 1, []).

%% Test before base case for $ -- end of line
amatch({Pattern, [PH|PT]}, [], Pos, PosList) when PH =:= $$ ->
amatch({Pattern, PT}, {[], []}, Pos, PosList);
amatch({Pattern, [PH|[]]}, {[], []}, Pos, PosList) when PH =:= $$ ->
% test case example: true = match("a$", [$b, $\n, $a]),
amatch({Pattern, Pattern}, [], Pos+1, lists:concat([PosList, [Pos]]));

%% Base cases
amatch(_, [], _, PosList) ->
    PosList;
amatch({_, []}, {[], []}, Pos, PosList) ->
    lists:concat([PosList, [Pos]]);
amatch(_, {[], []}, _, PosList) ->
    PosList;

%% $ -- match the end of line
%% we detect the end of the line by an empty Head
amatch({Pattern, [PH|_]}, {InitT, []}, Pos, PosList) when PH =:= $$ ->
amatch({Pattern, Pattern}, InitT, Pos+1, lists:concat([PosList, [Pos]]));
%% if there is a endline as the last sequential match, it's a match
amatch({Pattern, [PH|PT]}, {InitT, [$\n|T]}, Pos, PosList) when PH =:= $$ ->
case T =:= [] of
  true -> amatch({Pattern, PT}, {InitT, T}, Pos, PosList);
  false -> amatch({Pattern, Pattern}, InitT, Pos+1, PosList)
end;

%% % -- match the beginning of line
%% 1) if it's the beginning of line, keep position and
%%    test sequentially starting from the same position
%%    hence {[H|T], [H|T]} instead of {T, T}.
%% 2) if isn't the beginning of line, go to next position and
%%    test same pattern in Tail, it will obviously never match
%%    since Tail isn't the beginning anymore.
%%
%% Further tests is needed for this behavior.
amatch({Pattern, [PH|PT]}, [H|T], Pos, PosList) when PH =:= $% ->
    case Pos =:= 1 of
        true -> amatch({Pattern, PT}, {[H|T], [H|T]}, Pos, PosList);
        false -> amatch({Pattern, Pattern}, T, Pos+1, PosList)
    end;

%% ? -- match any single character except newline
%% if ? = 10 = newline, will be a mismatch
amatch({Pattern, [PH|PT]}, [H|T], Pos, PosList) when PH =:= $? ->
    case H =/= 10 of
        true -> amatch({Pattern, PT}, {T, T}, Pos, PosList);
        false -> amatch({Pattern, Pattern}, T, Pos+1, PosList)
    end;
amatch({Pattern, [PH|PT]}, {InitT, [H|T]}, Pos, PosList) when PH =:= $? ->
    case H =/= 10 of
        true -> amatch({Pattern, PT}, {InitT, T}, Pos, PosList);
        false -> amatch({Pattern, Pattern}, InitT, Pos+1, PosList)
    end;

%% sequence of literal characters
amatch({Pattern, []}, {InitT, _}, Pos, PosList) ->
    amatch({Pattern, Pattern}, InitT, Pos+1, lists:concat([PosList, [Pos]]));
amatch({Pattern, [PH|PT]}, {InitT, [H|T]}, Pos, PosList) ->
    case H =:= PH of
        true -> amatch({Pattern, PT}, {InitT, T}, Pos, PosList);
        false -> amatch({Pattern, Pattern}, InitT, Pos+1, PosList)
    end;

%% if a single match is found, will test a sequential match
%% a single literal is a sequence of a literal + empty list,
%% so we can reuse code from a sequence of literal characters
amatch({Pattern, [PH|PT]}, [H|T], Pos, PosList) ->
    case H =:= PH of
        true -> amatch({Pattern, PT}, {T, T}, Pos, PosList);
        false -> amatch({Pattern, Pattern}, T, Pos+1, PosList)
    end.

main([Pattern, File|_]) ->
    {Pattern, File};
main(["-t"|_]) ->
    test().

test() ->
    %% test 1 -- lines are properly read and written
    Input1 = "This is a single input.",
    Input1 = find("i", Input1),
    [] = find("z", Input1),

    %% test 2 -- find single character 'x' in text
    %%        -- find literal sequence 'xx' in text
    [] = amatch("z", "this is a single input"),

    [3, 6, 12] = amatch([$i], "This is a line"),
    [1,2,3,4,5,6] = amatch("a", "aaaaaa"),

    [6] = amatch("et", "Two letters"),
    [1,2,3,4,5] = amatch("aa", "aaaaaa"),

    %% test 3 -- match returns true or false
    true = match("et", "Two letters"),
    false = match("foobar", "foo bar"),

    %% test 4 -- ? matches any character except newline
    true = match("?", [32]), % ASCII 32 = whitespace
    true = match("?", " "),
    false = match("?", ""),
    true = match("?", "aaa"),
    false = match("?", [$\n]),

    AnyInput = "Match everything",
    AnyRange = lists:seq(1, erlang:length(AnyInput)),

    true = match("?", AnyInput),
    false = match("?z", AnyInput),
    AnyRange = amatch("?", AnyInput),
    AnyRange = amatch("?", AnyInput++[$\n]),
    [2, 11, 18, 27] = amatch("?t", AnyInput++AnyInput),
    [2, 11, 19, 28] = amatch("?t", AnyInput++[$\n]++AnyInput),

    true = match("?t?", AnyInput),
    [2, 11] = amatch("?t?", AnyInput),

    %% test 5 -- % beginning of line
    true = match("%abc", "abcc"),
    true = match("%", "abc"),
    true = match("%?", "abc"),
    true = match("%a?", "abc"),
    true = match("%a?c", "abc"),
    false = match("%a?b", "abc"),
    false = match("%bc", "abc"),
    false = match("%?c", "abc"),
    true = match("%?b", "abc"),
    false = match("%b", [$a, $\n, $b, $\n, $c]),

    [1] = amatch("%abc", "abcc"),
    [1] = amatch("%?", "abc"),
    [1] = amatch("%?b", "abc"),
    [] = amatch("%?c", "abc"),

%% test 6 -- $ end of line
true = match("abc$", "abc"),
true = match("$", "abc"),
true = match("abc$", "aabc"),
false = match("abc$", "aabcd"),

true = match("%abc$", "abc"),
false = match("%abc$", "abcc"),
false = match("%abc$", "aabc"),

true = match("$", [$a, $\n, $b, $\n]),
true = match("$", [$a, $\n, $b]),
false = match("a$", [$a, $\n, $b, $\n]),
true = match("a$", [$b, $\n, $a, $\n]),
true = match("a$", [$b, $\n, $a]),

false = match("aa$", [$a, $a, $\n, $b, $\n]),
true = match("aa$", [$b, $\n, $a, $a, $\n]),
true = match("aa$", [$b, $\n, $a, $a]),

    ok.

debug(Arg) ->
    ststd:putf("~w~n", [Arg]).

%% TODO
%%
%% [...] character class
%% [^...] negated character class
%% * closure (zero or more occurrences of previous pattern)
%%
%% @c escaped character (@%, @[, @*, @^, @-, @@, @])
%% an escape sequence consist of @n (newline), @t (tab)
%% or @c (escaped character)
